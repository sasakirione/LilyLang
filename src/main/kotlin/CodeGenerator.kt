import com.sasakirione.Expression
import com.sasakirione.Program
import com.sasakirione.Statement
import org.objectweb.asm.ClassWriter
import org.objectweb.asm.MethodVisitor
import org.objectweb.asm.Opcodes

/**
 * Code generator for LilyLang
 * Converts an AST into JVM bytecode
 */
class CodeGenerator {
    /**
     * Determine the type of an expression at compile time
     *
     * @param expr The expression to analyze
     * @param varIndexMap The variable index map
     * @return The type of the expression ("int", "boolean", "string", etc.)
     */
    private fun getExpressionType(expr: Expression, varIndexMap: List<VariableDetail>): String {
        return when (expr) {
            is Expression.IntLiteral -> "int"
            is Expression.BooleanLiteral -> "boolean"
            is Expression.StringLiteral -> "string"
            is Expression.VariableRef -> {
                val detail = varIndexMap.firstOrNull { it.name == expr.name }
                    ?: error("Undefined variable: ${expr.name}")
                detail.type
            }
            is Expression.Add -> {
                val leftType = getExpressionType(expr.left, varIndexMap)
                val rightType = getExpressionType(expr.right, varIndexMap)

                if (leftType == "string" || rightType == "string") {
                    "string"
                } else {
                    "int"
                }
            }
            is Expression.Sub, is Expression.Mul, is Expression.Div, is Expression.Mod -> "int"
            is Expression.And, is Expression.Or, is Expression.Not -> "boolean"
            is Expression.Equal, is Expression.NotEqual, 
            is Expression.LessThan, is Expression.GreaterThan, 
            is Expression.LessEqual, is Expression.GreaterEqual -> "boolean"
            is Expression.List -> "Object"
        }
    }
    /**
     * Generate bytecode for a program
     *
     * @param program The AST of the program
     * @param className The name of the class to generate
     * @return The generated bytecode as a byte array
     */
    fun generate(program: Program, className: String): ByteArray {
        val cw = ClassWriter(0)

        // Class definition: public class <className> extends Object
        cw.visit(
            Opcodes.V24,
            Opcodes.ACC_PUBLIC,
            className,
            null,
            "java/lang/Object",
            null
        )

        // Default constructor (public <init>())
        generateConstructor(cw)

        // Main method: public static void main(String[] args)
        generateMainMethod(cw, program)

        // Finish class definition
        cw.visitEnd()

        // Return bytecode as byte array
        return cw.toByteArray()
    }

    /**
     * Generate the default constructor
     *
     * @param cw The ClassWriter to use
     */
    private fun generateConstructor(cw: ClassWriter) {
        val mv = cw.visitMethod(
            Opcodes.ACC_PUBLIC,
            "<init>",
            "()V",
            null,
            null
        )
        mv.visitCode()
        mv.visitVarInsn(Opcodes.ALOAD, 0)
        mv.visitMethodInsn(
            Opcodes.INVOKESPECIAL,
            "java/lang/Object",
            "<init>",
            "()V",
            false
        )
        mv.visitInsn(Opcodes.RETURN)
        mv.visitMaxs(1, 1)
        mv.visitEnd()
    }

    /**
     * Generate the main method
     *
     * @param cw The ClassWriter to use
     * @param program The AST of the program
     */
    private fun generateMainMethod(cw: ClassWriter, program: Program) {
        val mv = cw.visitMethod(
            Opcodes.ACC_PUBLIC or Opcodes.ACC_STATIC,
            "main",
            "([Ljava/lang/String;)V",
            null,
            null
        )
        mv.visitCode()

        // Variable name -> local variable number mapping
        // main's local variable 0 is for args
        val varIndexMap = mutableListOf<VariableDetail>()
        var nextLocalIndex = 1

        // Generate code for each statement
        for (stmt in program.statements) {
            nextLocalIndex = generateStatement(stmt, mv, varIndexMap, nextLocalIndex)
        }

        // End of main method
        mv.visitInsn(Opcodes.RETURN)
        // Set stack size and local variable size
        mv.visitMaxs(2, nextLocalIndex)
        mv.visitEnd()
    }

    /**
     * Generate code for a statement
     *
     * @param stmt The statement to generate code for
     * @param mv The MethodVisitor to use
     * @param varIndexMap The variable index map
     * @param nextLocalIndex The next available local variable index
     * @return The updated next available local variable index
     */
    private fun generateStatement(
        stmt: Statement,
        mv: MethodVisitor,
        varIndexMap: MutableList<VariableDetail>,
        nextLocalIndex: Int
    ): Int {
        var updatedNextLocalIndex = nextLocalIndex

        when (stmt) {
            is Statement.VarDecl -> {
                val isExist = varIndexMap.any { it.name == stmt.varName }
                if (isExist) {
                    error("Variable redefinition not allowed: ${stmt.varName}")
                }

                // Generate code for the expression
                generateExpression(stmt.expr, mv, varIndexMap)

                // Determine the type of the expression
                val exprType = getExpressionType(stmt.expr, varIndexMap)

                // Store the value in a local variable
                varIndexMap.add(VariableDetail(exprType, updatedNextLocalIndex, stmt.varName))

                when (exprType) {
                    "string" -> {
                        // For strings (object references), use ASTORE
                        mv.visitVarInsn(Opcodes.ASTORE, updatedNextLocalIndex)
                    }
                    "Object" -> {
                        // For ArrayList instances (object references), use ASTORE
                        mv.visitVarInsn(Opcodes.ASTORE, updatedNextLocalIndex)
                    }
                    else -> {
                        // For integers and other primitives, use ISTORE
                        mv.visitVarInsn(Opcodes.ISTORE, updatedNextLocalIndex)
                    }
                }
                updatedNextLocalIndex++
            }

            is Statement.Print -> {
                // Generate code for the expression
                generateExpression(stmt.expr, mv, varIndexMap)

                // Get System.out
                mv.visitFieldInsn(
                    Opcodes.GETSTATIC,
                    "java/lang/System",
                    "out",
                    "Ljava/io/PrintStream;"
                )

                // Determine the type of the expression
                val exprType = getExpressionType(stmt.expr, varIndexMap)

                // Stack has [value, PrintStream], so swap them
                mv.visitInsn(Opcodes.SWAP)

                // Use the appropriate println method based on the expression type
                when (exprType) {
                    "string" -> {
                        mv.visitMethodInsn(
                            Opcodes.INVOKEVIRTUAL,
                            "java/io/PrintStream",
                            "println",
                            "(Ljava/lang/String;)V",
                            false
                        )
                    }
                    "boolean" -> {
                        // For booleans, we could convert 0/1 to "false"/"true" for better output
                        // But for simplicity, we'll just use println(int) for now
                        mv.visitMethodInsn(
                            Opcodes.INVOKEVIRTUAL,
                            "java/io/PrintStream",
                            "println",
                            "(I)V",
                            false
                        )
                    }
                    else -> {
                        // For integers and other types, use println(int)
                        mv.visitMethodInsn(
                            Opcodes.INVOKEVIRTUAL,
                            "java/io/PrintStream",
                            "println",
                            "(I)V",
                            false
                        )
                    }
                }
            }

            is Statement.VarAssign -> {
                val varDetail = varIndexMap.firstOrNull { it.name == stmt.varName }
                    ?: error("Variable not declared: ${stmt.varName}")

                // Generate code for the expression
                generateExpression(stmt.expr, mv, varIndexMap)

                // Store the value in the variable using the appropriate instruction
                when (varDetail.type) {
                    "string", "Object" -> {
                        // For strings and objects, use ASTORE
                        mv.visitVarInsn(Opcodes.ASTORE, varDetail.index)
                    }
                    else -> {
                        // For integers and other primitives, use ISTORE
                        mv.visitVarInsn(Opcodes.ISTORE, varDetail.index)
                    }
                }
            }

            is Statement.If -> {
                // Create labels for the else branch and end of if statement
                val elseLabel = org.objectweb.asm.Label()
                val endLabel = org.objectweb.asm.Label()

                // Generate code for the condition
                generateExpression(stmt.condition, mv, varIndexMap)

                // If condition is false (0), jump to else branch
                mv.visitJumpInsn(Opcodes.IFEQ, elseLabel)

                // Generate code for the then branch
                for (thenStmt in stmt.thenBranch) {
                    updatedNextLocalIndex = generateStatement(thenStmt, mv, varIndexMap, updatedNextLocalIndex)
                }

                // Jump to the end of the if statement
                mv.visitJumpInsn(Opcodes.GOTO, endLabel)

                // Else branch
                mv.visitLabel(elseLabel)

                // Generate code for the else branch if it exists
                if (stmt.elseBranch != null) {
                    for (elseStmt in stmt.elseBranch) {
                        updatedNextLocalIndex = generateStatement(elseStmt, mv, varIndexMap, updatedNextLocalIndex)
                    }
                }

                // End of if statement
                mv.visitLabel(endLabel)
            }

            is Statement.While -> {
                // Create labels for the start of the loop, condition check, and end of the loop
                val startLabel = org.objectweb.asm.Label()
                val conditionLabel = org.objectweb.asm.Label()
                val endLabel = org.objectweb.asm.Label()

                // Jump to the condition check
                mv.visitJumpInsn(Opcodes.GOTO, conditionLabel)

                // Start of the loop body
                mv.visitLabel(startLabel)

                // Generate code for the loop body
                for (bodyStmt in stmt.body) {
                    updatedNextLocalIndex = generateStatement(bodyStmt, mv, varIndexMap, updatedNextLocalIndex)
                }

                // Condition check
                mv.visitLabel(conditionLabel)

                // Generate code for the condition
                generateExpression(stmt.condition, mv, varIndexMap)

                // If condition is true (1), jump to the start of the loop
                mv.visitJumpInsn(Opcodes.IFNE, startLabel)

                // End of the loop
                mv.visitLabel(endLabel)
            }

            is Statement.For -> {
                // Create labels for the start of the loop, condition check, update, and end of the loop
                val startLabel = org.objectweb.asm.Label()
                val conditionLabel = org.objectweb.asm.Label()
                val updateLabel = org.objectweb.asm.Label()
                val endLabel = org.objectweb.asm.Label()

                // Generate code for the initialization if it exists
                if (stmt.initialization != null) {
                    updatedNextLocalIndex = generateStatement(stmt.initialization, mv, varIndexMap, updatedNextLocalIndex)
                }

                // Jump to the condition check
                mv.visitJumpInsn(Opcodes.GOTO, conditionLabel)

                // Start of the loop body
                mv.visitLabel(startLabel)

                // Generate code for the loop body
                for (bodyStmt in stmt.body) {
                    updatedNextLocalIndex = generateStatement(bodyStmt, mv, varIndexMap, updatedNextLocalIndex)
                }

                // Update
                mv.visitLabel(updateLabel)

                // Generate code for the update if it exists
                if (stmt.update != null) {
                    updatedNextLocalIndex = generateStatement(stmt.update, mv, varIndexMap, updatedNextLocalIndex)
                }

                // Condition check
                mv.visitLabel(conditionLabel)

                // Generate code for the condition
                generateExpression(stmt.condition, mv, varIndexMap)

                // If condition is true (1), jump to the start of the loop
                mv.visitJumpInsn(Opcodes.IFNE, startLabel)

                // End of the loop
                mv.visitLabel(endLabel)
            }
        }

        return updatedNextLocalIndex
    }

    /**
     * Generate code for an expression
     *
     * @param expr The expression to generate code for
     * @param mv The MethodVisitor to use
     * @param varIndexMap The variable index map
     */
    private fun generateExpression(
        expr: Expression,
        mv: MethodVisitor,
        varIndexMap: MutableList<VariableDetail>
    ) {
        when (expr) {
            is Expression.IntLiteral -> {
                // Push integer literal onto the stack
                mv.visitLdcInsn(expr.value)
            }
            is Expression.BooleanLiteral -> {
                // Push boolean literal onto the stack (1 for true, 0 for false)
                mv.visitLdcInsn(if (expr.value) 1 else 0)
            }
            is Expression.StringLiteral -> {
                // Push string literal onto the stack
                mv.visitLdcInsn(expr.value)
            }
            is Expression.VariableRef -> {
                // Load variable value onto the stack
                val detail = varIndexMap.firstOrNull { it.name == expr.name }
                    ?: error("Undefined variable: ${expr.name}")

                // Use appropriate load instruction based on variable type
                when (detail.type) {
                    "string" -> mv.visitVarInsn(Opcodes.ALOAD, detail.index)
                    else -> mv.visitVarInsn(Opcodes.ILOAD, detail.index)
                }
            }
            is Expression.Add -> {
                // Check if this is string concatenation
                val leftType = getExpressionType(expr.left, varIndexMap)
                val rightType = getExpressionType(expr.right, varIndexMap)

                if (leftType == "string" || rightType == "string") {
                    // String concatenation using StringBuilder
                    mv.visitTypeInsn(Opcodes.NEW, "java/lang/StringBuilder")
                    mv.visitInsn(Opcodes.DUP)
                    mv.visitMethodInsn(Opcodes.INVOKESPECIAL, "java/lang/StringBuilder", "<init>", "()V", false)

                    // Append left operand
                    generateExpression(expr.left, mv, varIndexMap)
                    if (leftType == "int") {
                        // Convert int to String
                        mv.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/String", "valueOf", "(I)Ljava/lang/String;", false)
                    }
                    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder", "append", 
                        if (leftType == "string") "(Ljava/lang/String;)Ljava/lang/StringBuilder;" else "(Ljava/lang/Object;)Ljava/lang/StringBuilder;", false)

                    // Append right operand
                    generateExpression(expr.right, mv, varIndexMap)
                    if (rightType == "int") {
                        // Convert int to String
                        mv.visitMethodInsn(Opcodes.INVOKESTATIC, "java/lang/String", "valueOf", "(I)Ljava/lang/String;", false)
                    }
                    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder", "append", 
                        if (rightType == "string") "(Ljava/lang/String;)Ljava/lang/StringBuilder;" else "(Ljava/lang/Object;)Ljava/lang/StringBuilder;", false)

                    // Convert StringBuilder to String
                    mv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, "java/lang/StringBuilder", "toString", "()Ljava/lang/String;", false)
                } else {
                    // Regular integer addition
                    generateExpression(expr.left, mv, varIndexMap)
                    generateExpression(expr.right, mv, varIndexMap)
                    mv.visitInsn(Opcodes.IADD)
                }
            }
            is Expression.Sub -> {
                // Generate code for left and right operands, then subtract
                generateExpression(expr.left, mv, varIndexMap)
                generateExpression(expr.right, mv, varIndexMap)
                mv.visitInsn(Opcodes.ISUB)
            }
            is Expression.Mul -> {
                // Generate code for left and right operands, then multiply
                generateExpression(expr.left, mv, varIndexMap)
                generateExpression(expr.right, mv, varIndexMap)
                mv.visitInsn(Opcodes.IMUL)
            }
            is Expression.Div -> {
                // Generate code for left and right operands, then divide
                generateExpression(expr.left, mv, varIndexMap)
                generateExpression(expr.right, mv, varIndexMap)
                mv.visitInsn(Opcodes.IDIV)
            }
            is Expression.Mod -> {
                // Generate code for left and right operands, then modulo
                generateExpression(expr.left, mv, varIndexMap)
                generateExpression(expr.right, mv, varIndexMap)
                mv.visitInsn(Opcodes.IREM)
            }
            is Expression.And -> {
                // Generate code for left and right operands, then AND
                generateExpression(expr.left, mv, varIndexMap)
                generateExpression(expr.right, mv, varIndexMap)
                mv.visitInsn(Opcodes.IAND)
            }
            is Expression.Or -> {
                // Generate code for left and right operands, then OR
                generateExpression(expr.left, mv, varIndexMap)
                generateExpression(expr.right, mv, varIndexMap)
                mv.visitInsn(Opcodes.IOR)
            }
            is Expression.Not -> {
                // Generate code for the expression, then NOT
                generateExpression(expr.expr, mv, varIndexMap)

                // XOR with 1 to negate (0 becomes 1, 1 becomes 0)
                mv.visitLdcInsn(1)
                mv.visitInsn(Opcodes.IXOR)
            }
            is Expression.Equal -> {
                // Generate code for left and right operands
                generateExpression(expr.left, mv, varIndexMap)
                generateExpression(expr.right, mv, varIndexMap)

                // Compare for equality (result is 0 if equal, 1 if not equal)
                val label1 = org.objectweb.asm.Label()
                val label2 = org.objectweb.asm.Label()
                mv.visitJumpInsn(Opcodes.IF_ICMPEQ, label1)
                mv.visitLdcInsn(0) // Not equal, push 0 (false)
                mv.visitJumpInsn(Opcodes.GOTO, label2)
                mv.visitLabel(label1)
                mv.visitLdcInsn(1) // Equal, push 1 (true)
                mv.visitLabel(label2)
            }
            is Expression.NotEqual -> {
                // Generate code for left and right operands
                generateExpression(expr.left, mv, varIndexMap)
                generateExpression(expr.right, mv, varIndexMap)

                // Compare for inequality (result is 1 if not equal, 0 if equal)
                val label1 = org.objectweb.asm.Label()
                val label2 = org.objectweb.asm.Label()
                mv.visitJumpInsn(Opcodes.IF_ICMPNE, label1)
                mv.visitLdcInsn(0) // Equal, push 0 (false)
                mv.visitJumpInsn(Opcodes.GOTO, label2)
                mv.visitLabel(label1)
                mv.visitLdcInsn(1) // Not equal, push 1 (true)
                mv.visitLabel(label2)
            }
            is Expression.LessThan -> {
                // Generate code for left and right operands
                generateExpression(expr.left, mv, varIndexMap)
                generateExpression(expr.right, mv, varIndexMap)

                // Compare for less than (result is 1 if less than, 0 if not)
                val label1 = org.objectweb.asm.Label()
                val label2 = org.objectweb.asm.Label()
                mv.visitJumpInsn(Opcodes.IF_ICMPLT, label1)
                mv.visitLdcInsn(0) // Not less than, push 0 (false)
                mv.visitJumpInsn(Opcodes.GOTO, label2)
                mv.visitLabel(label1)
                mv.visitLdcInsn(1) // Less than, push 1 (true)
                mv.visitLabel(label2)
            }
            is Expression.GreaterThan -> {
                // Generate code for left and right operands
                generateExpression(expr.left, mv, varIndexMap)
                generateExpression(expr.right, mv, varIndexMap)

                // Compare for greater than (result is 1 if greater than, 0 if not)
                val label1 = org.objectweb.asm.Label()
                val label2 = org.objectweb.asm.Label()
                mv.visitJumpInsn(Opcodes.IF_ICMPGT, label1)
                mv.visitLdcInsn(0) // Not greater than, push 0 (false)
                mv.visitJumpInsn(Opcodes.GOTO, label2)
                mv.visitLabel(label1)
                mv.visitLdcInsn(1) // Greater than, push 1 (true)
                mv.visitLabel(label2)
            }
            is Expression.LessEqual -> {
                // Generate code for left and right operands
                generateExpression(expr.left, mv, varIndexMap)
                generateExpression(expr.right, mv, varIndexMap)

                // Compare for less than or equal (result is 1 if less than or equal, 0 if not)
                val label1 = org.objectweb.asm.Label()
                val label2 = org.objectweb.asm.Label()
                mv.visitJumpInsn(Opcodes.IF_ICMPLE, label1)
                mv.visitLdcInsn(0) // Not less than or equal, push 0 (false)
                mv.visitJumpInsn(Opcodes.GOTO, label2)
                mv.visitLabel(label1)
                mv.visitLdcInsn(1) // Less than or equal, push 1 (true)
                mv.visitLabel(label2)
            }
            is Expression.GreaterEqual -> {
                // Generate code for left and right operands
                generateExpression(expr.left, mv, varIndexMap)
                generateExpression(expr.right, mv, varIndexMap)

                // Compare for greater than or equal (result is 1 if greater than or equal, 0 if not)
                val label1 = org.objectweb.asm.Label()
                val label2 = org.objectweb.asm.Label()
                mv.visitJumpInsn(Opcodes.IF_ICMPGE, label1)
                mv.visitLdcInsn(0) // Not greater than or equal, push 0 (false)
                mv.visitJumpInsn(Opcodes.GOTO, label2)
                mv.visitLabel(label1)
                mv.visitLdcInsn(1) // Greater than or equal, push 1 (true)
                mv.visitLabel(label2)
            }
            is Expression.List -> {
                // Create a new ArrayList
                mv.visitTypeInsn(Opcodes.NEW, "java/util/ArrayList")
                mv.visitInsn(Opcodes.DUP) // Duplicate the reference
                mv.visitMethodInsn(
                    Opcodes.INVOKESPECIAL,
                    "java/util/ArrayList",
                    "<init>",
                    "()V",
                    false
                )
            }
        }
    }
}
